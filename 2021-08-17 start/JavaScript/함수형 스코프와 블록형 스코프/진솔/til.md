### 블록형 스코프와 함수형 스코프

#### var

var는 es6 전까지 사용되던 변수의 선언자이다.(물론 es6이후에도 사용은 가능)

특징

- 변수 호이스팅이 된다

- 선언자 주제에 생략이 가능하다(파이썬처럼)

- 변수 중복선언이 가능하다 

  ```javascript
  // 예시
  var a
  var a
  a
  
  // 중복선언도 되며 값 할당을 안해줘도 된다(이떄의 a의 값은 undefined)
  ```

- **함수형 스코프이다 !!** 

#### let

let은 es6에 나온 변수 선언자로 var를 대체할 선언자로 생각하면 된다

- 변수 중복선언이 안된다

  ```js
  let a
  // 얘도 var 선언자와 마찬가지로 선언시 값 할당을 안해줘도 된다
  let a = undefined
  // 하면 신텍스에러가 뜬다
  ```

- 변수 호이스팅이 되지 않는다(실제로는 호이스팅이 되는데 이거는 호이스팅 파트에서 다룰 예정)

- **블록형 스코프이다 !!** 

####  const

const는 es6에 나온 **상수** 선언자이다.

- 값의 재할당이 되지 않는다

  ```js
  const a = "123"
  a = "456"
  // constant 에러가 뜬다 
  // 자바의 const 선언자랑 같은 이치
  ```

- 값의 할당없이 선인이 되지 않는다

  ```js
  const b
  // 초기값 없다고 에러가 뜬다
  ```

- 이 외의 특징은 let과 같다



#### 함수형 스코프와 블록형 스코프

##### 함수형 스코프

콜스택 안에 들어가는 함수단위가 스코프(함수 안에서만 참조 가능)가 된다.

해당 함수(메인함수 포함)에서 선언된 모든 변수가 전부 같은레벨의 변수로 호이스팅되어 변수 참조에 오류가 잦을 수 있다.

```js
function () {
    var a = 1
    console.log(b)
    if() {
       function () {
        	var b = 2
    	}();
    }
}

function () {
    var a
    
    a = 1
    if() {
       function () {
        	var b
            b = 2
    	}();
    }
}
```



블록형스코프를 가진 변수선언자가 나오기 전까진 블록 내에 함수를 끼워넣어 함수의 클로저기능(함수 선언 스코프의 변수객체를 기억)을 사용해 이슈를 처리했다.

##### 블록형 스코프

코드블록 내에서 선언된 변수는 해당 블록의 스코프(블록 내에서만 참조 가능) 가 된다.

코드블록이란 `function`이나 `if` `for` 같이 `{}` 로 구분된 코드 단위를 의미

```js
{
    let b
}
```
