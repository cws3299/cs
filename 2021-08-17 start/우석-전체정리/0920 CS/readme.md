### 2021-09-20 

CS5 / 중복되는 내용도 또 반복

_____________

__:black_flag:AJAX란?__

- Ajax는 JavaScript라이브러리중 하나이며 __Asynchronous JavaScript And Xml(비동기식 자바스크립트와 xml)__의 약자입니다. 

- `전체 페이지를 새로 고치지 않고도 페이지의 일부만을 위한 데이터를 로딩하는 기법`

- 쉽게 말해 __비동기 통신 , 클라이언트와 서버간에 데이터를 주고받는 기술__

- ```txt
  화면의 내용을 갱신하기 위해서는 request와 response과정을 진행하며 페이지 전체를 갱신한다. 하지만 이렇게 진행할 경우 페이지의 일부분만을 갱신하려고 해도 모든 페이지를 갱신해야하는 시간과 자원낭비가 발생함. 그러나 ajax를 활용할 경우 전체가 아닌 변화하는 일부만 갱신시키면서 시간과 자원을 효율적으로 활용함
  ```



__:black_flag:GET과 POST의 차이는? __

- GET방식과 POST방식은 HTTP 프로토콜을 이용해서 서버에 무언가를 전달할 때 사용하는 방식
- __GET방식__은 클라이언트에서 서버로 데이터를 전달할 때, 주소 뒤에 Key와 value가 결함된 쿼리스트링 형태로 전달함. 이에 따라 주소창에 쿼리스트링이 보여지기 때문에 보안성이 떨어짐, 또한 길이에 제한이 있으므로 전송데이터의 한계가 있지만 POST방식보다 상대적으로 빠르다.
- __POST방식__은 일정 크기 이상의 데이터를보내야할 때 사용합니다. 서버로 보내기 전에 인코딩하고, 전송 후 서버에서 다시 디코딩 작업을 수행함. 주소창에 데이터 정보가 노출되지 않아 GET방식에 비해 보안성이 높음. 전송 속도가 GET방식에 비해 느리지만 쿼리스트링 뿐만이 아닌 다양한 객체 값들도 전송가능
- 중요한 차이점은 헤더의 유무 , 보안성 , 전달방식을 예로 들 수 있다.



__:black_flag:객체지향과 절차지향 프로그래밍에 대해 설명하시오__

- __객체지향 프로그래밍__이란 실제 세계를 모델링하여 소프트웨어를 개발하는 방법입니다. 객체지향의 3대특징은 캡슐화 , 상속 , 다형성이 있습니다. 객체지향 프로그래밍의 장점은 코드 재활용성이 높고 코딩방식이 절차지향에 비해 간단하며 디버깅이 쉽습니다. 반면 단점으로는 처리속도가 절차지향에 비해 상대적으로 느리며, 설계에 많은 시간이 소요됩니다.
- __절차지향 프로그래밍__이란 물이 위에서 아래로 흐르는 것처럼 순차적인 처리가 중요시 되며, 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법입니다. 컴퓨터의 작업 처리 방식과 유사하기 때문에 객체지향 언어를 사용하는 것에 비해 더 빨리 처리되어 시간적으로 유리하다는 특징이 있습니다. 반면 객체 지향 언어에 비해 유지 보수가 어려우며 실행 순서가 정해져 있으므로 코드의 순서가 바뀌면 동일한 결과를 보장하기 어렵다는 점과 디버깅의 어려움이 있습니다.
- `객체지향의 반대는 절차지향이 아니며 절차지향의 반대는 객체지향이 아닙니다.` 절차지향은 데이터를 중심으로 함수를 구현하고, 객체지향은 기능을 중심으로 메소드를 구현합니다.



__:black_flag:REST란 무엇이고, RESTful하게 API를 디자인 한다는 것은 무엇인가요?__

- REST느 Represntational State Transfer의 약자입니다. 간단히 말해서 URI와 HTTP 메소드를 이용해 객체화된 서비스에 접근하는 것입니다. REST의 요소로는 크게 리소스, 메소드 , 메세지 3가지 요소로 구성됩니다. HTTP에는 여러가지 메소드가 있지만 REST에서는 CRUD에 해당하는 4가지의 메소드 GET,POST,PUT,DELETE를 사용합니다. REST는 리소스 지향 아키텍쳐 스타일 이라는 정의에 맞게 모든 것을 명사로 표현하며 각 세부 리소스에는 id를 붙입니다.
- Restful하게 API를 디자인 한다는 것은 URI를 규칙에 맞게 잘 설계했는지의 여부입니다. 규칙의 항목으로는 아래와 같습니다.
  - 동일한 URI의 행위에 맞게 GET, POST,  DELETE, PATCH 등의 메소드를 사용한다.
  - 명사를 사용한다. 리스트를 표현할 때는 복수형을 사용한다.
  - URI Path에 불필요한 파라미터를 넣지 않는다. 즉 단계를 심플하게 설계한다.



__:black_flag:화살표 함수를 사용했을 때는 new 생성자를 사용해서 새로운 객체고 상속등을 할 수 없습니다. 그 이유에 대해서 설명해주세요__



__화살표 함수__

- 화살표 함수는 단순히 함수를 '짧게'쓰기 위한 용도로 사용되지 않습니다. 화살표 함수는 몇 가지 독특하고 유용한 기능을 제공합니다.
- 자바스크립트를 사용하다 보면 저 멀리 동떨어진 곳에서 실행될 작은 함수를 작성해야 하는 상황을 자주 만나게 됩니다.

  - `arr.forEach(func)` - `func`은 `forEach`가 호출될 때 배열 `arr`의 요소 전체를 대상으로 실행됩니다.
  - `setTimeout(func)` - `func`은 내장 스케줄러에 의해 실행됩니다.
  - 기타 등등
- 이처럼 자바스크립트에선 함수를 생성하고 그 함수를 어딘가에 전달하는 것이 아주 자연스럽습니다.
- 그런데 어딘가에 함수를 전달하게 되면 함수의 컨텍스트를 잃을 수 있습니다. 이럴 때 화살표 함수를사용하면 현재 컨텍스트를 잃지 않아도 되어 편리합니다.



__화살표 함수에는 'this'가 없습니다__

화살표 함수 본문에서 `this`에 접근하면, 외부에서 값을 가져옵니다.

  - ```js
    let group = {
      title: "1모둠",
      students: ["보라", "호진", "지민"],
    
      showList() {
        this.students.forEach(
          student => alert(this.title + ': ' + student)
        );
      }
    };
    
    group.showList();
    ```

  - 예시의 `forEach`에서 화살표 함수를 사용했기 때문에 화살표 함수 본문에 있는 `this.title`은 화살표 함수 바깥에 있는 `showList`가 가리키는 대상과 동일해집니다. 즉 `this.title`은 `group.title`과 같습니다.

  - 위 예시에서 화살표 함수 대신 '일반' 함수를 사용했다면 에러가 발생했을 겁니다.

  - ```js
    let group = {
      title: "1모둠",
      students: ["보라", "호진", "지민"],
    
      showList() {
        this.students.forEach(function(student) {
          // TypeError: Cannot read property 'title' of undefined
          alert(this.title + ': ' + student)
        });
      }
    };
    
    group.showList();
    ```

  - 에러는 `forEach`에 전달되는 함수의 `this`가 `undefined`이기 때문에 발생하였습니다. `alert`함수에서 `undefined.title`에 접근하려 했기 때문에 얼럿 창엔 에러가 출력됩니다.

  - 그런데 화살표 함수는 `this`자체가 없기 때문에 이런 에러가 발생하지 않습니다.



`화살표 함수는 new와 함께 실행할 수 없습니다.`

> this가 없기 때문에 화살표 함수는 생성자 함수로 사용할 수 없다는 제약이 있습니다. 화살표 함수는  `new`와 함께 호출할 수 없습니다.

- 화살표 함수 vs bind
  - 화살표 함수와 일반 함수에 `.bind(this)`를 사용하서 호출하는 것 사이에는 미묘한 차이가 있습니다.
    - `.bind(this)`는 함수의 한정된 버전을 만듭니다.
    - 화살표 함수는 어떤 것도 바인딩 시키지 않습니다. 화살표 함수엔 단지 `this`가 없을 뿐입니다. 화살표 함수에서 `this`를 사용하면 일반 변수 서칭과 마찬가지로 `this`의 값을 외부 렉시컬 환경에서 찾습니다.







래퍼런스

(https://wooaoe.tistory.com/)

(https://velog.io/@suyeonme/%ED%9B%84%EA%B8%B0-%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EB%A9%B4%EC%A0%91-%EC%A0%95%EB%A6%AC)

(https://ko.javascript.info/arrow-functions)