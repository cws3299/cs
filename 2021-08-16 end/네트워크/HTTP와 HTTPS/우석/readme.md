### Http / Https



- Http란?



 <b>HTTP</b> (hyper text transfer protocol)는 인터넷에서 데이터를 주고받을 수 있는 프로토콜

- 웹 상에서 클라이언트와 서버가 서로 요청(request)/응답(response)을 받는 규칙이라고 생각
- <b>특징</b>
  - HTML문서와 같은 리소스를 가져오는 프로토콜
  - HTTP는 웹에서 이루어지는 모든 데이터 교환의 기초이며 서버와 클라이언트의 대화 규칙
  - 문서
    - 문서 : 텍스트 , 레이아웃 설명 , 이미지 , 비디오 , 스크립트 등 다양한 하위문서들로 재구성됨
  - HTTP는 애플리케이션 계층의 프로토콜로서  <B>TCP</B> 혹은 TCP연결인 <B>TLS</B>를 통해 전송됨
    1. HTTP는 텍스트 문서뿐만 아니라 이미지 , 비디오 등의 데이터를 가져올 수도
    2. POST등을 통해 데이터를 보내는 데도 사용할 수 있음
    3. HTTP는 웹페이지 갱신등 위한 일부 문서만을 가져오는데도 사용됨 
- <B>HTTP 기반 시스템의 구성요소</B>
  - 요청은 하나의 개체, 사용자 에이전트(프록시)에 의해 전송됨
  - 대부분의 경우 사용자 에이전트는 <B>브라우저</B>지만 다른게 될 수 도 있음
    - 브라우저가 아닌 경우는 웹에 관련된 봇들을 예로 들 수 있음
  - 각각의 개별적인 요청은 클라이언트에서 서버로 보내지며 , 서버는 요청을 처리하고 response라는 응답을 제공한다. 
    - 요청과 응답 사이에는 여러 개체들이 존재함, 게이트웨이 , 프록시, 모뎀 등이 존재
- 클라이언트
  - 사용자를 대신해 주는 도구 주로 <b>브라우저</b>
  - 브라우저는 항상 요청을 보내주는 개체로서 서버라고 할 수 없다(최근 여러 매커니즘이 추가되었지만....)
- 서버
  - 클라이언트의 요청에 응답하는 주체, 서버는 논리적으로 단일개체
- 프록시
  - 애플리케이션 계층에서 동작하는 많은 작동들을 프록시라고 함



<b>HTTP</b>와 <B>HTTPS</B> 의 큰 차이

#### <b>HTTP</b>

- TCP와 UDP를 사용하며 80번 포트를 사용함
- Statelees(무상태)
  - 연결이 끊어지는 순간 클라이언트와 서버의 통신은 끊어짐 
  - 이러한 상황에서 상태를 확인 및 저장하기 위해 브라우저와 서버는 쿠키나 세션등을 사용함
- Connectionless(비연결)
  - 클라이언트와 서버는 요청과 응답이 끝나는 순간 바로 연결이 끊어진다.

#### <b>HTTPS</b>

- HyperText Transfer protocol over Secure Socket Layer
- HTTP의 보안이 강화된 버전의 프로토콜
- HTTPS의 기본 TCP/IP 포트로 443번 포트를 주로 사용함
  - HTTPS는 소켓 통신에서 일반 텍스트를 이용하는 대신에, 웹 상에서 정보를 암호화하는 SSL이나 TLS 프로토콜을 통해 세션 데이터를 암호화 함
    - TLS 프로토콜은 SSL프로토콜의 발전 버전
    - 금융정보와 같은 중요정보는 HTTPS를 활용, 아무 상관이 없는 페이지는 HTTP를 사용하는게 추천됨
- HTTP는 서버와 클라이언트가 보안화 되지 않은 파일을 서로 주고 받는것을 의미
  - 중간에 누군가 정보를 가로챈다면 파일은 보안화 되어 있지 않아서 매우 위험함
  - 그래서 누군가 가로채도 해석하거나 쉽게 읽을 수 없도록 HTTPS로 보안을 설정하는 것
- HTTP의 장단점
  - 보안상에 헛점이 존재
    - TCP/IP는 도청이 가능한 네트워크이다.
      - 패킷을 수집하는 것만으로도 도청할 수 있기때문에 중요한 정보는 암호화하는게 좋음
      - 암호화방법
        1. 통신 자체를 SSL이나 TLS라는 다른 프로토콜을 조합하여 HTTP를 암호화함
        2. HTTP 전체가 아닌 콘텐츠만 암호화함 -> 전송 받은 측에서 해독하는 과정이 필요
    -  HTTP는 통신상대가 누군지 확인하는 과정이 없기 때문에 누구든 요청을 보낼 수 있음, 그래서 IP주소나 포트등 웹 서버에대한 엑세스 제한이 없는 경우 엄청난 문제점이 발생가능
      1. 통신에 허가된 상대가 누구인지 확인 할 수 없음
      2. 누가 요청을 보냈는지 알 수 없음
      3. 의미없는 요청도 받음 -> Ddos공격 ㅠㅠ
    - 보완방법 -> SSL을 사용함 (제 3자의 기관에서 발행되는 것이기 때문에)
    - 중간자 공격에 취약함
      - A라는 클라이언트가 서버에 보내는 요청을 누군가 중간에 가로채서 요청을 바꿔서 서버에 요청할 수도 있음
      - 마찬가지로 응답의 과정도 바꿔서 응답할 수 있음
      - 보완 방법
        - MD5, SHA-1등의 보완방식이 있지만 완전히 안전하지는 않음. HTTPS를 사용하는것이 추천됨
- HTTPS의 원리
  - 장점
    - 안전하다!!!!!!
  - 단점
    - 암호화 과정에서 서버에 무리를 준다
    - HTTPS 설치 및 인증서 유지에 추가비용이 듬
    - HTTP에 비해 느리다
    - HTTPS는 소켓 형식으로 인터넷이 끊이면 다시 HTTPS인증이 필요함
  - 공개키 알고리즘 방식
    - 공개키 : 모두에게 공개함
    - 개인키 : 클라이언트 - 서버 구조에서는 서버가 가지고 있음
  - 클라이언트는 사용자의 데이터를 공개키로 암호화 서버로 전송
  - 서버는 개인키를 통해 복호화해서 처리
  - 궁금증?? 적정 이용자가 아닌 제3자가 공개키로 서버에 보낸다면????
  - HTTPS는 SSL의 껍질을 덮어쓴 HTTP라고 할 수 있다. HTTPS는 HTTP의 통신하는 소켓 부분을 SSL이나 TLS로 대체한것을 의미 
    - 원래는 HTTP <-> TCP 직접통신 했지만
    - HTTPS는 중간에 SSL이 낌으로서 보안의 과정을 거침  HTTPS는 공통키와 공개키 암호화 방식을 모두 활용함. 공개키 암호화 방식으로 공통키를 교환한 후 그 후 공통키 암호 방식을 활용



- 공개키 알고리즘
  - 서로 다른 A와 B가 있다.
  - 이 열쇠는 두개의 열쇠 중 하나로 잠그면 반드시 잠근것과는 다른 열쇠로만 풀 수 있음
    - 편의를 위해 A는 공개키 B를 개인키로 명명하겠음
  - 공개키로 암호화 한 경우 (누구든 메세지 작성 -> 개인키를 가진 사람만 복호화가능)
  - 개인키로 암호화한 경우(전자서명) -> 공개키로 복호화해서 복호가 된다면 보낸사람은 개인키를 가진 사람
    - 예를 들어 내가 공인인증서 (개인키)를 가지고 있을 경우 내가 보낸 메세지는 공개키로 열림 -> 즉 내가 개인키 소유자라는게 증명됨
    - 전자서명의 경우 공개키도 아무에게나 주어지지 않고 개인키 발급자와 상호 합의한 자에게만 전달됨 (인증기관을 통해)
- 대칭키 알고리즘
  - A와 B로만 열수 있는 자물쇠(C)가 존재함 (A와 B는 같은 열쇠로서 이용자가 많아짐에 따라 더욱 많아질 수 있음)
  - A로 암호화 하면 똑같은 대칭키를 가진 사람만이 열 수 있음
  - 안전하고 빠르지만 문제점이 존재
    - 처음에 서로 키를 안전하게 교환해야함
    - 키를 누군가에게 노출된 순간 안전성이 크게 떨어짐\
    - 키를 공유하는 사람이 많아질 수록 키 관리가 어려워짐
    - 대표 알고리즘 : DES, 3DES ,AES ,SEED ,ARIA





[참고 사이트] 

(https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Network)

(https://github.com/WeareSoft/tech-interview/blob/master/contents/network.md#2-network)

(https://developer.mozilla.org/ko/docs/Web/HTTP)