## HTTP의 GET과 POST 비교

#### HTTP

> 웹상에서 클라이언트와 서버 간에 요청/응답으로 데이터를 주고 받을 수 있는 프로토콜



### GET

> 서버로부터 정보를 조회하기 위해 설계된 메소드

요청을 전송할 때 필요한 데이터를 Body에 담지 않고, 쿼리스트링을 통해 전송.

URL뒤에 `?`와 함께 이름과 값을 쌍을 이루는 요청 파라미터를 쿼리스트링이라 부름.

파라미터가 여러개 일때 `&`로 연결.

EX) www.example?name1=value1&name=value

GET은 불필요한 요청을 제한하기 위해 요청이 캐시 될 수 있다.

=> JS,CSS,IMAGE 같은 정적 컨텐츠는 데이터양이 크고 변경될 일이 적어서 반복해서 동일한 요청을 보낼 필요가 없다. 정적 컨텐츠를 요청하고 나면 브라우저에서는 요청을 캐시해둔다. 동일한 요청이 발생할 때 서버로 요청하지 않고 캐시된 데이터를 사용한다. 정적 컨텐츠가 캐시되어 컨텐츠를 변경해도 내용이 바뀌지 않은 경우 브라우저의 캐시를 지워주고 재요청을 보내면 된다.



[특징]

- URL에 쿼리스트링(데이터)를 포함시켜 요청(URL 길이 제약)
- 데이터를 Header에 포함하여 전송
- URL에 데이터가 노출되어 보안에 취약
- 캐싱가능 



### POST

> 리소스를 생성/변경하기 위해 설계된 메소드

HTTP 메세지의 BODY에 담아서 전송하기 때문에 길이의 제한 없이 데이터 전송 가능.

데이터가 Body로 전송되고 내용이 눈에 보이지 않아서 GET 보다 보안성이 좋다고 생각할 수 있지만 크롬 개발자도구, Fiddler와 같은 툴로 요청 내용을 확인 가능하기 때문에 민감데이터의 경우 반드시 암호화해 전송해야 한다.

Content-Type에 요청 데이터의 타입을 표시해야 한다.

-> 데이터 타입을 표시하지 않으면 서버는 내용이나 URL에 포함된 리소스의 확장자명 등으로 데이터 타입을 유추한다. 만약, 알 수 없는 경우 `application/octet-stream`로 요청을 처리한다.



[특징]

- URL에 쿼리스트링(데이터)를 노출하지 않고 요청
- 데이터를 Body에 담아 전송.
- URL에 데이터가 노출되어 있지 않지만 보안성이 뛰어난 것은 아님. 민감데이터의 경우 암호화해 전송.
- 캐싱할 수 없다.



### GET과 POST 차이

GET으로 서버에게 동일한 요청을 여러 번 전송해도 동일한 동일한 응답이 돌아온다. 설계원칙에 따라 서버의 데이터나 상태를 변경시키지 않아야 하기 때문에 주로 조회를 할때에 사용해야한다.

POST는 서버에게 동일한 요청을 여러번 전송해도 응답은 항상 다를 수 있다. 서버의 상태나 데이터를 변경시킬 때 사용된다. 





###### 참고

- https://hongsii.github.io/2017/08/02/what-is-the-difference-get-and-post/
- https://mangkyu.tistory.com/17